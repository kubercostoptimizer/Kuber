{"version":3,"sources":["../../src/tracer.js"],"names":["constants","opentracing","Tracer","serviceName","reporter","NoopReporter","sampler","ConstSampler","options","_tags","tags","Utils","clone","JAEGER_CLIENT_VERSION_TAG_KEY","version","TRACER_HOSTNAME_TAG_KEY","os","hostname","PROCESS_IP","myIp","_metrics","metrics","Metrics","NoopMetricFactory","_serviceName","_reporter","_sampler","_logger","logger","NullLogger","_baggageSetter","BaggageSetter","baggageRestrictionManager","DefaultBaggageRestrictionManager","_debugThrottler","debugThrottler","DefaultThrottler","_injectors","_extractors","codecOptions","contextKey","baggagePrefix","urlEncoding","textCodec","TextMapCodec","registerInjector","FORMAT_TEXT_MAP","registerExtractor","httpCodec","FORMAT_HTTP_HEADERS","binaryCodec","BinaryCodec","FORMAT_BINARY","uuid","TRACER_CLIENT_ID_TAG_KEY","_process","convertObjectToTags","setProcess","spanContext","operationName","startTime","userTags","internalTags","parentContext","rpcServer","references","hadParent","isDebugIDContainerOnly","span","Span","addTags","context","isSampled","spansStartedSampled","increment","tracesStartedSampled","tracesJoinedSampled","spansStartedNotSampled","tracesStartedNotSampled","tracesJoinedNotSampled","spansFinished","report","format","injector","extractor","now","followsFromIsParent","parent","childOf","i","length","ref","type","REFERENCE_CHILD_OF","referencedContext","REFERENCE_FOLLOWS_FROM","spanKindValue","opentracing_tags","SPAN_KIND","SPAN_KIND_RPC_SERVER","ctx","SpanContext","isValid","randomId","getRandom64","flags","SAMPLED_MASK","_isDebugAllowed","DEBUG_MASK","JAEGER_DEBUG_HEADER","debugId","baggage","traceId","spanId","parentId","finalizeSampling","_startInternalSpan","carrier","Error","inject","extract","callback","close","Date","operation","isAllowed"],"mappings":"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","file":"tracer.js","sourcesContent":["// @flow\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport BinaryCodec from './propagators/binary_codec';\nimport ConstSampler from './samplers/const_sampler';\nimport * as constants from './constants';\nimport * as opentracing from 'opentracing';\nimport { Tags as opentracing_tags } from 'opentracing';\nimport NoopReporter from './reporters/noop_reporter';\nimport Span from './span';\nimport SpanContext from './span_context';\nimport TextMapCodec from './propagators/text_map_codec';\nimport NullLogger from './logger';\nimport Utils from './util';\nimport Metrics from './metrics/metrics';\nimport NoopMetricFactory from './metrics/noop/metric_factory';\nimport DefaultBaggageRestrictionManager from './baggage/default_baggage_restriction_manager';\nimport os from 'os';\nimport BaggageSetter from './baggage/baggage_setter';\nimport DefaultThrottler from './throttler/default_throttler';\nimport uuidv4 from 'uuid/v4';\nimport version from './version';\n\nexport default class Tracer {\n  _serviceName: string;\n  _reporter: Reporter;\n  _sampler: Sampler;\n  _logger: NullLogger;\n  _tags: any;\n  _injectors: any;\n  _extractors: any;\n  _metrics: any;\n  _baggageSetter: BaggageSetter;\n  _debugThrottler: Throttler & ProcessSetter;\n  _process: Process;\n\n  /**\n   * @param {String} [serviceName] - name of the current service or application.\n   * @param {Object} [reporter] - reporter used to submit finished spans to Jaeger backend.\n   * @param {Object} [sampler] - sampler used to decide if trace should be sampled when starting a new one.\n   * @param {Object} [options] - the fields to set on the newly created span.\n   * @param {Object} [options.tags] - set of key-value pairs which will be set\n   *        as process-level tags on the Tracer itself.\n   * @param {Object} [options.metrics] - instance of the Metrics class from ./metrics/metrics.js.\n   * @param {Object} [options.logger] - a logger matching NullLogger API from ./logger.js.\n   * @param {Object} [options.baggageRestrictionManager] - a baggageRestrictionManager matching\n   * @param {Object} [options.contextKey] - a name of the key to extract/inject context from headers\n   * @param {Object} [options.baggagePrefix] - a name of the context baggage key prefix\n   * BaggageRestrictionManager API from ./baggage.js.\n   */\n  constructor(\n    serviceName: string,\n    reporter: Reporter = new NoopReporter(),\n    sampler: Sampler = new ConstSampler(false),\n    options: any = {}\n  ) {\n    this._tags = options.tags ? Utils.clone(options.tags) : {};\n    this._tags[constants.JAEGER_CLIENT_VERSION_TAG_KEY] = `Node-${version}`;\n    this._tags[constants.TRACER_HOSTNAME_TAG_KEY] =\n      this._tags[constants.TRACER_HOSTNAME_TAG_KEY] || os.hostname();\n    this._tags[constants.PROCESS_IP] = this._tags[constants.PROCESS_IP] || Utils.myIp();\n\n    this._metrics = options.metrics || new Metrics(new NoopMetricFactory());\n\n    this._serviceName = serviceName;\n    this._reporter = reporter;\n    this._sampler = sampler;\n    this._logger = options.logger || new NullLogger();\n    this._baggageSetter = new BaggageSetter(\n      options.baggageRestrictionManager || new DefaultBaggageRestrictionManager(),\n      this._metrics\n    );\n    this._debugThrottler = options.debugThrottler || new DefaultThrottler(false);\n    this._injectors = {};\n    this._extractors = {};\n\n    let codecOptions = {\n      contextKey: options.contextKey || null,\n      baggagePrefix: options.baggagePrefix || null,\n      urlEncoding: false,\n      metrics: this._metrics,\n    };\n\n    let textCodec = new TextMapCodec(codecOptions);\n    this.registerInjector(opentracing.FORMAT_TEXT_MAP, textCodec);\n    this.registerExtractor(opentracing.FORMAT_TEXT_MAP, textCodec);\n\n    codecOptions.urlEncoding = true;\n\n    let httpCodec = new TextMapCodec(codecOptions);\n    this.registerInjector(opentracing.FORMAT_HTTP_HEADERS, httpCodec);\n    this.registerExtractor(opentracing.FORMAT_HTTP_HEADERS, httpCodec);\n\n    let binaryCodec = new BinaryCodec();\n    this.registerInjector(opentracing.FORMAT_BINARY, binaryCodec);\n    this.registerExtractor(opentracing.FORMAT_BINARY, binaryCodec);\n\n    const uuid = uuidv4();\n    this._tags[constants.TRACER_CLIENT_ID_TAG_KEY] = uuid;\n    this._process = {\n      serviceName: serviceName,\n      tags: Utils.convertObjectToTags(this._tags),\n      uuid: uuid,\n    };\n    this._debugThrottler.setProcess(this._process);\n    // TODO update reporter to implement ProcessSetter\n    this._reporter.setProcess(this._process.serviceName, this._process.tags);\n  }\n\n  _startInternalSpan(\n    spanContext: SpanContext,\n    operationName: string,\n    startTime: number,\n    userTags: any,\n    internalTags: any,\n    parentContext: ?SpanContext,\n    rpcServer: boolean,\n    references: Array<Reference>\n  ): Span {\n    let hadParent = parentContext && !parentContext.isDebugIDContainerOnly();\n    let span = new Span(this, operationName, spanContext, startTime, references);\n\n    span.addTags(userTags);\n    span.addTags(internalTags);\n\n    // emit metrics\n    if (span.context().isSampled()) {\n      this._metrics.spansStartedSampled.increment(1);\n      if (!hadParent) {\n        this._metrics.tracesStartedSampled.increment(1);\n      } else if (rpcServer) {\n        this._metrics.tracesJoinedSampled.increment(1);\n      }\n    } else {\n      this._metrics.spansStartedNotSampled.increment(1);\n      if (!hadParent) {\n        this._metrics.tracesStartedNotSampled.increment(1);\n      } else if (rpcServer) {\n        this._metrics.tracesJoinedNotSampled.increment(1);\n      }\n    }\n\n    return span;\n  }\n\n  _report(span: Span): void {\n    this._metrics.spansFinished.increment(1);\n    this._reporter.report(span);\n  }\n\n  registerInjector(format: string, injector: Injector): void {\n    this._injectors[format] = injector;\n  }\n\n  registerExtractor(format: string, extractor: Extractor): void {\n    this._extractors[format] = extractor;\n  }\n\n  /**\n   * The method for creating a root or child span.\n   *\n   * @param {string} operationName - the name of the operation.\n   * @param {object} [options] - the fields to set on the newly created span.\n   * @param {string} options.operationName - the name to use for the newly\n   *        created span. Required if called with a single argument.\n   * @param {SpanContext} [options.childOf] - a parent SpanContext (or Span,\n   *        for convenience) that the newly-started span will be the child of\n   *        (per REFERENCE_CHILD_OF). If specified, `fields.references` must\n   *        be unspecified.\n   * @param {array} [options.references] - an array of Reference instances,\n   *        each pointing to a causal parent SpanContext. If specified,\n   *        `fields.childOf` must be unspecified.\n   * @param {object} [options.tags] - set of key-value pairs which will be set\n   *        as tags on the newly created Span. Ownership of the object is\n   *        passed to the created span for efficiency reasons (the caller\n   *        should not modify this object after calling startSpan).\n   * @param {number} [options.startTime] - a manually specified start time for\n   *        the created Span object. The time should be specified in\n   *        milliseconds as Unix timestamp. Decimal value are supported\n   *        to represent time values with sub-millisecond accuracy.\n   * @return {Span} - a new Span object.\n   **/\n  startSpan(operationName: string, options: ?startSpanOptions): Span {\n    // Convert options.childOf to options.references as needed.\n    options = options || {};\n    let references = options.references || [];\n\n    let userTags = options.tags || {};\n    let startTime = options.startTime || this.now();\n\n    // This flag is used to ensure that CHILD_OF reference is preferred\n    // as a parent even if it comes after FOLLOWS_FROM reference.\n    let followsFromIsParent = false;\n    let parent: ?SpanContext = options.childOf instanceof Span ? options.childOf.context() : options.childOf;\n    // If there is no childOf in options, then search list of references\n    for (let i = 0; i < references.length; i++) {\n      let ref: Reference = references[i];\n      if (ref.type() === opentracing.REFERENCE_CHILD_OF) {\n        if (!parent || followsFromIsParent) {\n          parent = ref.referencedContext();\n          break;\n        }\n      } else if (ref.type() === opentracing.REFERENCE_FOLLOWS_FROM) {\n        if (!parent) {\n          parent = ref.referencedContext();\n          followsFromIsParent = true;\n        }\n      }\n    }\n\n    let spanKindValue = userTags[opentracing_tags.SPAN_KIND];\n    let rpcServer = spanKindValue === opentracing_tags.SPAN_KIND_RPC_SERVER;\n\n    let ctx: SpanContext = new SpanContext();\n    let internalTags: any = {};\n    if (!parent || !parent.isValid) {\n      let randomId = Utils.getRandom64();\n      let flags = 0;\n      if (this._sampler.isSampled(operationName, internalTags)) {\n        flags |= constants.SAMPLED_MASK;\n      }\n\n      if (parent) {\n        if (parent.isDebugIDContainerOnly() && this._isDebugAllowed(operationName)) {\n          flags |= constants.SAMPLED_MASK | constants.DEBUG_MASK;\n          internalTags[constants.JAEGER_DEBUG_HEADER] = parent.debugId;\n        }\n        // baggage that could have been passed via `jaeger-baggage` header\n        ctx.baggage = parent.baggage;\n      }\n\n      ctx.traceId = randomId;\n      ctx.spanId = randomId;\n      ctx.parentId = null;\n      ctx.flags = flags;\n    } else {\n      ctx.traceId = parent.traceId;\n      ctx.spanId = Utils.getRandom64();\n      ctx.parentId = parent.spanId;\n      ctx.flags = parent.flags;\n\n      // reuse parent's baggage as we'll never change it\n      ctx.baggage = parent.baggage;\n\n      parent.finalizeSampling();\n      ctx.finalizeSampling();\n    }\n\n    return this._startInternalSpan(\n      ctx,\n      operationName,\n      startTime,\n      userTags,\n      internalTags,\n      parent,\n      rpcServer,\n      references\n    );\n  }\n\n  /**\n   * Saves the span context into the carrier object for various formats, and encoders.\n   *\n   * @param  {SpanContext} spanContext - the SpanContext to inject into the\n   *         carrier object. As a convenience, a Span instance may be passed\n   *         in instead (in which case its .context() is used for the\n   *         inject()).\n   * @param  {string} format - the format of the carrier.\n   * @param  {any} carrier - see the documentation for the chosen `format`\n   *         for a description of the carrier object.\n   **/\n  inject(spanContext: SpanContext | Span, format: string, carrier: any): void {\n    if (!spanContext) {\n      return;\n    }\n\n    let injector = this._injectors[format];\n    if (!injector) {\n      throw new Error(`Unsupported format: ${format}`);\n    }\n\n    if (spanContext instanceof Span) {\n      spanContext = spanContext.context();\n    }\n\n    spanContext.finalizeSampling();\n    injector.inject(spanContext, carrier);\n  }\n\n  /**\n   * Responsible for extracting a span context from various serialized formats.\n   *\n   * @param  {string} format - the format of the carrier.\n   * @param  {any} carrier - the type of the carrier object is determined by\n   *         the format.\n   * @return {SpanContext}\n   *         The extracted SpanContext, or null if no such SpanContext could\n   *         be found in `carrier`\n   */\n  extract(format: string, carrier: any): SpanContext {\n    let extractor = this._extractors[format];\n    if (!extractor) {\n      throw new Error(`Unsupported format: ${format}`);\n    }\n\n    let spanContext = extractor.extract(carrier);\n\n    if (spanContext) {\n      spanContext.finalizeSampling();\n    }\n    return spanContext;\n  }\n\n  /**\n   * Closes the tracer, flushes spans, and executes any callbacks if necessary.\n   *\n   * @param {Function} [callback] - a callback that runs after the tracer has been closed.\n   **/\n  close(callback: Function): void {\n    let reporter = this._reporter;\n    this._reporter = new NoopReporter();\n    reporter.close(() => {\n      this._sampler.close(callback);\n    });\n    this._debugThrottler.close();\n  }\n\n  /**\n   * Returns the current timestamp in milliseconds since the Unix epoch.\n   * Fractional values are allowed so that timestamps with sub-millisecond\n   * accuracy can be represented.\n   */\n  now(): number {\n    // TODO investigate process.hrtime; verify it is available in all Node versions.\n    // http://stackoverflow.com/questions/11725691/how-to-get-a-microtime-in-node-js\n    return Date.now();\n  }\n\n  _isDebugAllowed(operation: string): boolean {\n    return this._debugThrottler.isAllowed(operation);\n  }\n}\n"]}