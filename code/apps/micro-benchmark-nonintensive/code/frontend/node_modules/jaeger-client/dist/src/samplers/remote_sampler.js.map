{"version":3,"sources":["../../../src/samplers/remote_sampler.js"],"names":["DEFAULT_INITIAL_SAMPLING_RATE","DEFAULT_REFRESH_INTERVAL","DEFAULT_MAX_OPERATIONS","DEFAULT_SAMPLING_HOST","DEFAULT_SAMPLING_PORT","PROBABILISTIC_STRATEGY_TYPE","RATELIMITING_STRATEGY_TYPE","RemoteControlledSampler","serviceName","options","_serviceName","_sampler","sampler","ProbabilisticSampler","_logger","logger","NullLogger","_metrics","metrics","Metrics","NoopMetricFactory","_refreshInterval","refreshInterval","_maxOperations","maxOperations","hostPort","_parseHostPort","_host","host","_port","port","_onSamplerUpdate","onSamplerUpdate","randomDelay","Math","random","_initialDelayTimeoutHandle","setTimeout","_afterInitialDelay","bind","name","test","parsedUrl","url","parse","hostname","parseInt","_refreshIntervalHandle","setInterval","_refreshSamplingStrategy","encodeURIComponent","success","_parseSamplingServerResponse","body","error","err","samplerQueryFailure","increment","Utils","httpGet","samplerRetrieved","strategy","JSON","samplerUpdateFailure","_updateSampler","samplerUpdated","response","operationSampling","PerOperationSampler","update","newSampler","strategyType","probabilisticSampling","samplingRate","rateLimitingSampling","maxTracesPerSecond","RateLimitingSampler","stringify","equal","operation","tags","isSampled","callback","clearTimeout","clearInterval"],"mappings":"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","file":"remote_sampler.js","sourcesContent":["// @flow\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport url from 'url';\nimport ProbabilisticSampler from './probabilistic_sampler.js';\nimport RateLimitingSampler from './ratelimiting_sampler.js';\nimport PerOperationSampler from './per_operation_sampler.js';\nimport Metrics from '../metrics/metrics.js';\nimport NullLogger from '../logger.js';\nimport NoopMetricFactory from '../metrics/noop/metric_factory';\nimport Utils from '../util';\n\nconst DEFAULT_INITIAL_SAMPLING_RATE = 0.001;\nconst DEFAULT_REFRESH_INTERVAL = 60000;\nconst DEFAULT_MAX_OPERATIONS = 2000;\nconst DEFAULT_SAMPLING_HOST = '0.0.0.0';\nconst DEFAULT_SAMPLING_PORT = 5778;\nconst PROBABILISTIC_STRATEGY_TYPE = 'PROBABILISTIC';\nconst RATELIMITING_STRATEGY_TYPE = 'RATE_LIMITING';\n\nexport default class RemoteControlledSampler {\n  _serviceName: string;\n  _sampler: Sampler;\n  _logger: Logger;\n  _metrics: Metrics;\n\n  _refreshInterval: number;\n  _host: string;\n  _port: number;\n  _maxOperations: number;\n\n  _onSamplerUpdate: ?Function;\n\n  _initialDelayTimeoutHandle: any;\n  _refreshIntervalHandle: any;\n\n  /**\n   * Creates a sampler remotely controlled by jaeger-agent.\n   *\n   * @param {string} [serviceName] - name of the current service / application, same as given to Tracer\n   * @param {object} [options] - optional settings\n   * @param {object} [options.sampler] - initial sampler to use prior to retrieving strategies from Agent\n   * @param {object} [options.logger] - optional logger, see _flow/logger.js\n   * @param {object} [options.metrics] - instance of Metrics object\n   * @param {number} [options.refreshInterval] - interval in milliseconds before sampling strategy refreshes (0 to not refresh)\n   * @param {string} [options.hostPort] - host and port for jaeger-agent, defaults to 'localhost:5778'\n   * @param {string} [options.host] - host for jaeger-agent, defaults to 'localhost'\n   * @param {number} [options.port] - port for jaeger-agent for SamplingManager endpoint\n   * @param {number} [options.maxOperations] - max number of operations to track in PerOperationSampler\n   * @param {function} [options.onSamplerUpdate]\n   */\n  constructor(serviceName: string, options: any = {}) {\n    this._serviceName = serviceName;\n    this._sampler = options.sampler || new ProbabilisticSampler(DEFAULT_INITIAL_SAMPLING_RATE);\n    this._logger = options.logger || new NullLogger();\n    this._metrics = options.metrics || new Metrics(new NoopMetricFactory());\n    this._refreshInterval = options.refreshInterval || DEFAULT_REFRESH_INTERVAL;\n    this._maxOperations = options.maxOperations || DEFAULT_MAX_OPERATIONS;\n    if (options.hostPort) {\n      this._parseHostPort(options.hostPort);\n    } else {\n      this._host = options.host || DEFAULT_SAMPLING_HOST;\n      this._port = options.port || DEFAULT_SAMPLING_PORT;\n    }\n    this._onSamplerUpdate = options.onSamplerUpdate;\n\n    if (options.refreshInterval !== 0) {\n      let randomDelay: number = Math.random() * this._refreshInterval;\n      this._initialDelayTimeoutHandle = setTimeout(this._afterInitialDelay.bind(this), randomDelay);\n    }\n  }\n\n  name(): string {\n    return 'RemoteSampler';\n  }\n\n  toString(): string {\n    return `${this.name()}(serviceName=${this._serviceName})`;\n  }\n\n  _parseHostPort(hostPort: string) {\n    hostPort = /^http/.test(hostPort) ? hostPort : `http://${hostPort}`;\n    const parsedUrl = url.parse(hostPort);\n\n    this._host = parsedUrl.hostname || DEFAULT_SAMPLING_HOST;\n    this._port = parsedUrl.port ? parseInt(parsedUrl.port) : DEFAULT_SAMPLING_PORT;\n  }\n\n  _afterInitialDelay(): void {\n    this._refreshIntervalHandle = setInterval(\n      this._refreshSamplingStrategy.bind(this),\n      this._refreshInterval\n    );\n    this._initialDelayTimeoutHandle = null;\n  }\n\n  _refreshSamplingStrategy() {\n    let serviceName: string = encodeURIComponent(this._serviceName);\n    const success: Function = body => {\n      this._parseSamplingServerResponse(body);\n    };\n    const error: Function = err => {\n      this._logger.error(`Error in fetching sampling strategy: ${err}.`);\n      this._metrics.samplerQueryFailure.increment(1);\n    };\n    Utils.httpGet(this._host, this._port, `/sampling?service=${serviceName}`, success, error);\n  }\n\n  _parseSamplingServerResponse(body: string) {\n    this._metrics.samplerRetrieved.increment(1);\n    let strategy;\n    try {\n      strategy = JSON.parse(body);\n      if (!strategy) {\n        throw 'Malformed response: ' + body;\n      }\n    } catch (error) {\n      this._logger.error(`Error in parsing sampling strategy: ${error}.`);\n      this._metrics.samplerUpdateFailure.increment(1);\n      return;\n    }\n    try {\n      if (this._updateSampler(strategy)) {\n        this._metrics.samplerUpdated.increment(1);\n      }\n    } catch (error) {\n      this._logger.error(`Error in updating sampler: ${error}.`);\n      this._metrics.samplerUpdateFailure.increment(1);\n      return;\n    }\n    if (this._onSamplerUpdate) {\n      this._onSamplerUpdate(this._sampler);\n    }\n  }\n\n  _updateSampler(response: SamplingStrategyResponse): boolean {\n    if (response.operationSampling) {\n      if (this._sampler instanceof PerOperationSampler) {\n        let sampler: PerOperationSampler = this._sampler;\n        return sampler.update(response.operationSampling);\n      }\n      this._sampler = new PerOperationSampler(response.operationSampling, this._maxOperations);\n      return true;\n    }\n    let newSampler: Sampler;\n    if (response.strategyType === PROBABILISTIC_STRATEGY_TYPE && response.probabilisticSampling) {\n      let samplingRate = response.probabilisticSampling.samplingRate;\n      newSampler = new ProbabilisticSampler(samplingRate);\n    } else if (response.strategyType === RATELIMITING_STRATEGY_TYPE && response.rateLimitingSampling) {\n      let maxTracesPerSecond = response.rateLimitingSampling.maxTracesPerSecond;\n      if (this._sampler instanceof RateLimitingSampler) {\n        let sampler: RateLimitingSampler = this._sampler;\n        return sampler.update(maxTracesPerSecond);\n      }\n      this._sampler = new RateLimitingSampler(maxTracesPerSecond);\n      return true;\n    } else {\n      throw 'Malformed response: ' + JSON.stringify(response);\n    }\n\n    if (this._sampler.equal(newSampler)) {\n      return false;\n    }\n    this._sampler = newSampler;\n    return true;\n  }\n\n  isSampled(operation: string, tags: any): boolean {\n    return this._sampler.isSampled(operation, tags);\n  }\n\n  close(callback: ?Function): void {\n    clearTimeout(this._initialDelayTimeoutHandle);\n    clearInterval(this._refreshIntervalHandle);\n\n    if (callback) {\n      callback();\n    }\n  }\n}\n"]}